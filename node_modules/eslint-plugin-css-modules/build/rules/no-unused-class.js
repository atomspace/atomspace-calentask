'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fp = require('lodash/fp');

var _fp2 = _interopRequireDefault(_fp);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _core = require('../core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  meta: {
    docs: {
      description: 'Checks that you are using all css/scss/less classes',
      recommended: true
    },
    schema: [{
      type: 'object',
      properties: {
        camelCase: { enum: [true, 'dashes', 'only', 'dashes-only'] },
        markAsUsed: { type: 'array' }
      }
    }]
  },
  create: function create(context) {
    var dirName = _path2.default.dirname(context.getFilename());
    var markAsUsed = _lodash2.default.get(context, 'options[0].markAsUsed');
    var camelCase = _lodash2.default.get(context, 'options[0].camelCase');

    /*
       maps variable name to property Object
       map = {
         [variableName]: {
           classes: { foo: false, 'foo-bar': false },
           classesMap: { foo: 'foo', fooBar: 'foo-bar', 'foo-bar': 'foo-bar' },
           node: {...}
         }
       }
        example:
       import s from './foo.scss';
       s is variable name
        property Object has two keys
       1. classes: an object with className as key and a boolean as value. The boolean is marked if it is used in file
       2. classesMap: an object with propertyName as key and its className as value
       3. node: node that correspond to s (see example above)
     */
    var map = {};

    return {
      ImportDeclaration: function ImportDeclaration(node) {
        var styleImportNodeData = (0, _core.getStyleImportNodeData)(node);

        if (!styleImportNodeData) {
          return;
        }

        var importName = styleImportNodeData.importName,
            styleFilePath = styleImportNodeData.styleFilePath,
            importNode = styleImportNodeData.importNode;


        var styleFileAbsolutePath = _path2.default.resolve(dirName, styleFilePath);

        // this will be used to mark s.foo as used in MemberExpression
        var classes = (0, _core.getStyleClasses)(styleFileAbsolutePath);
        var classesMap = classes && (0, _core.getClassesMap)(classes, camelCase);

        _lodash2.default.set(map, importName + '.classes', classes);
        _lodash2.default.set(map, importName + '.classesMap', classesMap);

        // save node for reporting unused styles
        _lodash2.default.set(map, importName + '.node', importNode);
      },

      MemberExpression: function MemberExpression(node) {
        /*
           Check if property exists in css/scss file as class
         */

        var objectName = node.object.name;
        var propertyName = (0, _core.getPropertyName)(node, camelCase);

        if (!propertyName) {
          return;
        }

        var className = _lodash2.default.get(map, objectName + '.classesMap.' + propertyName);

        if (className == null) {
          return;
        }

        // mark this property has used
        _lodash2.default.set(map, objectName + '.classes.' + className, true);
      },
      'Program:exit': function ProgramExit() {
        /*
           Check if all classes defined in css/scss file are used
         */

        /*
           we are looping over each import style node in program
           example:
           ```
             import s from './foo.css';
             import x from './bar.scss';
           ```
           then the loop will be run 2 times
         */
        _lodash2.default.forIn(map, function (o) {
          var classes = o.classes,
              node = o.node;

          /*
             if option is passed to mark a class as used, example:
             eslint css-modules/no-unused-class: [2, { markAsUsed: ['container'] }]
           */

          _lodash2.default.forEach(markAsUsed, function (usedClass) {
            classes[usedClass] = true;
          });

          // classNames not marked as true are unused
          var unusedClasses = _fp2.default.compose(_fp2.default.keys, _fp2.default.omitBy(_fp2.default.identity))(classes);

          if (!_lodash2.default.isEmpty(unusedClasses)) {
            context.report(node, 'Unused classes found: ' + unusedClasses.join(', '));
          }
        });
      }
    };
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9ydWxlcy9uby11bnVzZWQtY2xhc3MuanMiXSwibmFtZXMiOlsibWV0YSIsImRvY3MiLCJkZXNjcmlwdGlvbiIsInJlY29tbWVuZGVkIiwic2NoZW1hIiwidHlwZSIsInByb3BlcnRpZXMiLCJjYW1lbENhc2UiLCJlbnVtIiwibWFya0FzVXNlZCIsImNyZWF0ZSIsImNvbnRleHQiLCJkaXJOYW1lIiwiZGlybmFtZSIsImdldEZpbGVuYW1lIiwiZ2V0IiwibWFwIiwiSW1wb3J0RGVjbGFyYXRpb24iLCJub2RlIiwic3R5bGVJbXBvcnROb2RlRGF0YSIsImltcG9ydE5hbWUiLCJzdHlsZUZpbGVQYXRoIiwiaW1wb3J0Tm9kZSIsInN0eWxlRmlsZUFic29sdXRlUGF0aCIsInJlc29sdmUiLCJjbGFzc2VzIiwiY2xhc3Nlc01hcCIsInNldCIsIk1lbWJlckV4cHJlc3Npb24iLCJvYmplY3ROYW1lIiwib2JqZWN0IiwibmFtZSIsInByb3BlcnR5TmFtZSIsImNsYXNzTmFtZSIsImZvckluIiwibyIsImZvckVhY2giLCJ1c2VkQ2xhc3MiLCJ1bnVzZWRDbGFzc2VzIiwiY29tcG9zZSIsImtleXMiLCJvbWl0QnkiLCJpZGVudGl0eSIsImlzRW1wdHkiLCJyZXBvcnQiLCJqb2luIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztrQkFTZTtBQUNiQSxRQUFNO0FBQ0pDLFVBQU07QUFDSkMsbUJBQWEscURBRFQ7QUFFSkMsbUJBQWE7QUFGVCxLQURGO0FBS0pDLFlBQVEsQ0FDTjtBQUNFQyxZQUFNLFFBRFI7QUFFRUMsa0JBQVk7QUFDVkMsbUJBQVcsRUFBRUMsTUFBTSxDQUFDLElBQUQsRUFBTyxRQUFQLEVBQWlCLE1BQWpCLEVBQXlCLGFBQXpCLENBQVIsRUFERDtBQUVWQyxvQkFBWSxFQUFFSixNQUFNLE9BQVI7QUFGRjtBQUZkLEtBRE07QUFMSixHQURPO0FBZ0JiSyxRQWhCYSxrQkFnQkxDLE9BaEJL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IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZnAgZnJvbSAnbG9kYXNoL2ZwJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCB7XG4gIGdldFN0eWxlSW1wb3J0Tm9kZURhdGEsXG4gIGdldFN0eWxlQ2xhc3NlcyxcbiAgZ2V0UHJvcGVydHlOYW1lLFxuICBnZXRDbGFzc2VzTWFwLFxufSBmcm9tICcuLi9jb3JlJztcblxuaW1wb3J0IHR5cGUgeyBKc05vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbWV0YToge1xuICAgIGRvY3M6IHtcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ2hlY2tzIHRoYXQgeW91IGFyZSB1c2luZyBhbGwgY3NzL3Njc3MvbGVzcyBjbGFzc2VzJyxcbiAgICAgIHJlY29tbWVuZGVkOiB0cnVlLFxuICAgIH0sXG4gICAgc2NoZW1hOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgY2FtZWxDYXNlOiB7IGVudW06IFt0cnVlLCAnZGFzaGVzJywgJ29ubHknLCAnZGFzaGVzLW9ubHknXSB9LFxuICAgICAgICAgIG1hcmtBc1VzZWQ6IHsgdHlwZTogJ2FycmF5JyB9LFxuICAgICAgICB9LFxuICAgICAgfVxuICAgIF0sXG4gIH0sXG4gIGNyZWF0ZSAoY29udGV4dDogT2JqZWN0KSB7XG4gICAgY29uc3QgZGlyTmFtZSA9IHBhdGguZGlybmFtZShjb250ZXh0LmdldEZpbGVuYW1lKCkpO1xuICAgIGNvbnN0IG1hcmtBc1VzZWQgPSBfLmdldChjb250ZXh0LCAnb3B0aW9uc1swXS5tYXJrQXNVc2VkJyk7XG4gICAgY29uc3QgY2FtZWxDYXNlID0gXy5nZXQoY29udGV4dCwgJ29wdGlvbnNbMF0uY2FtZWxDYXNlJyk7XG5cbiAgICAvKlxuICAgICAgIG1hcHMgdmFyaWFibGUgbmFtZSB0byBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICBtYXAgPSB7XG4gICAgICAgICBbdmFyaWFibGVOYW1lXToge1xuICAgICAgICAgICBjbGFzc2VzOiB7IGZvbzogZmFsc2UsICdmb28tYmFyJzogZmFsc2UgfSxcbiAgICAgICAgICAgY2xhc3Nlc01hcDogeyBmb286ICdmb28nLCBmb29CYXI6ICdmb28tYmFyJywgJ2Zvby1iYXInOiAnZm9vLWJhcicgfSxcbiAgICAgICAgICAgbm9kZTogey4uLn1cbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICBleGFtcGxlOlxuICAgICAgIGltcG9ydCBzIGZyb20gJy4vZm9vLnNjc3MnO1xuICAgICAgIHMgaXMgdmFyaWFibGUgbmFtZVxuXG4gICAgICAgcHJvcGVydHkgT2JqZWN0IGhhcyB0d28ga2V5c1xuICAgICAgIDEuIGNsYXNzZXM6IGFuIG9iamVjdCB3aXRoIGNsYXNzTmFtZSBhcyBrZXkgYW5kIGEgYm9vbGVhbiBhcyB2YWx1ZS4gVGhlIGJvb2xlYW4gaXMgbWFya2VkIGlmIGl0IGlzIHVzZWQgaW4gZmlsZVxuICAgICAgIDIuIGNsYXNzZXNNYXA6IGFuIG9iamVjdCB3aXRoIHByb3BlcnR5TmFtZSBhcyBrZXkgYW5kIGl0cyBjbGFzc05hbWUgYXMgdmFsdWVcbiAgICAgICAzLiBub2RlOiBub2RlIHRoYXQgY29ycmVzcG9uZCB0byBzIChzZWUgZXhhbXBsZSBhYm92ZSlcbiAgICAgKi9cbiAgICBjb25zdCBtYXAgPSB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICBJbXBvcnREZWNsYXJhdGlvbiAobm9kZTogSnNOb2RlKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlSW1wb3J0Tm9kZURhdGEgPSBnZXRTdHlsZUltcG9ydE5vZGVEYXRhKG5vZGUpO1xuXG4gICAgICAgIGlmICghc3R5bGVJbXBvcnROb2RlRGF0YSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpbXBvcnROYW1lLFxuICAgICAgICAgIHN0eWxlRmlsZVBhdGgsXG4gICAgICAgICAgaW1wb3J0Tm9kZSxcbiAgICAgICAgfSA9IHN0eWxlSW1wb3J0Tm9kZURhdGE7XG5cbiAgICAgICAgY29uc3Qgc3R5bGVGaWxlQWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKGRpck5hbWUsIHN0eWxlRmlsZVBhdGgpO1xuXG4gICAgICAgIC8vIHRoaXMgd2lsbCBiZSB1c2VkIHRvIG1hcmsgcy5mb28gYXMgdXNlZCBpbiBNZW1iZXJFeHByZXNzaW9uXG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBnZXRTdHlsZUNsYXNzZXMoc3R5bGVGaWxlQWJzb2x1dGVQYXRoKTtcbiAgICAgICAgY29uc3QgY2xhc3Nlc01hcCA9IGNsYXNzZXMgJiYgZ2V0Q2xhc3Nlc01hcChjbGFzc2VzLCBjYW1lbENhc2UpO1xuXG4gICAgICAgIF8uc2V0KG1hcCwgYCR7aW1wb3J0TmFtZX0uY2xhc3Nlc2AsIGNsYXNzZXMpO1xuICAgICAgICBfLnNldChtYXAsIGAke2ltcG9ydE5hbWV9LmNsYXNzZXNNYXBgLCBjbGFzc2VzTWFwKTtcblxuICAgICAgICAvLyBzYXZlIG5vZGUgZm9yIHJlcG9ydGluZyB1bnVzZWQgc3R5bGVzXG4gICAgICAgIF8uc2V0KG1hcCwgYCR7aW1wb3J0TmFtZX0ubm9kZWAsIGltcG9ydE5vZGUpO1xuICAgICAgfSxcbiAgICAgIE1lbWJlckV4cHJlc3Npb246IChub2RlOiBKc05vZGUpID0+IHtcbiAgICAgICAgLypcbiAgICAgICAgICAgQ2hlY2sgaWYgcHJvcGVydHkgZXhpc3RzIGluIGNzcy9zY3NzIGZpbGUgYXMgY2xhc3NcbiAgICAgICAgICovXG5cbiAgICAgICAgY29uc3Qgb2JqZWN0TmFtZSA9IG5vZGUub2JqZWN0Lm5hbWU7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGdldFByb3BlcnR5TmFtZShub2RlLCBjYW1lbENhc2UpO1xuXG4gICAgICAgIGlmICghcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gXy5nZXQobWFwLCBgJHtvYmplY3ROYW1lfS5jbGFzc2VzTWFwLiR7cHJvcGVydHlOYW1lfWApO1xuXG4gICAgICAgIGlmIChjbGFzc05hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hcmsgdGhpcyBwcm9wZXJ0eSBoYXMgdXNlZFxuICAgICAgICBfLnNldChtYXAsIGAke29iamVjdE5hbWV9LmNsYXNzZXMuJHtjbGFzc05hbWV9YCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgJ1Byb2dyYW06ZXhpdCcgKCkge1xuICAgICAgICAvKlxuICAgICAgICAgICBDaGVjayBpZiBhbGwgY2xhc3NlcyBkZWZpbmVkIGluIGNzcy9zY3NzIGZpbGUgYXJlIHVzZWRcbiAgICAgICAgICovXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgd2UgYXJlIGxvb3Bpbmcgb3ZlciBlYWNoIGltcG9ydCBzdHlsZSBub2RlIGluIHByb2dyYW1cbiAgICAgICAgICAgZXhhbXBsZTpcbiAgICAgICAgICAgYGBgXG4gICAgICAgICAgICAgaW1wb3J0IHMgZnJvbSAnLi9mb28uY3NzJztcbiAgICAgICAgICAgICBpbXBvcnQgeCBmcm9tICcuL2Jhci5zY3NzJztcbiAgICAgICAgICAgYGBgXG4gICAgICAgICAgIHRoZW4gdGhlIGxvb3Agd2lsbCBiZSBydW4gMiB0aW1lc1xuICAgICAgICAgKi9cbiAgICAgICAgXy5mb3JJbihtYXAsIChvKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBjbGFzc2VzLCBub2RlIH0gPSBvO1xuXG4gICAgICAgICAgLypcbiAgICAgICAgICAgICBpZiBvcHRpb24gaXMgcGFzc2VkIHRvIG1hcmsgYSBjbGFzcyBhcyB1c2VkLCBleGFtcGxlOlxuICAgICAgICAgICAgIGVzbGludCBjc3MtbW9kdWxlcy9uby11bnVzZWQtY2xhc3M6IFsyLCB7IG1hcmtBc1VzZWQ6IFsnY29udGFpbmVyJ10gfV1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfLmZvckVhY2gobWFya0FzVXNlZCwgKHVzZWRDbGFzcykgPT4ge1xuICAgICAgICAgICAgY2xhc3Nlc1t1c2VkQ2xhc3NdID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGNsYXNzTmFtZXMgbm90IG1hcmtlZCBhcyB0cnVlIGFyZSB1bnVzZWRcbiAgICAgICAgICBjb25zdCB1bnVzZWRDbGFzc2VzID0gZnAuY29tcG9zZShcbiAgICAgICAgICAgIGZwLmtleXMsXG4gICAgICAgICAgICBmcC5vbWl0QnkoZnAuaWRlbnRpdHkpLCAvLyBvbWl0IHRydXRoeSB2YWx1ZXNcbiAgICAgICAgICApKGNsYXNzZXMpO1xuXG4gICAgICAgICAgaWYgKCFfLmlzRW1wdHkodW51c2VkQ2xhc3NlcykpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVwb3J0KG5vZGUsIGBVbnVzZWQgY2xhc3NlcyBmb3VuZDogJHt1bnVzZWRDbGFzc2VzLmpvaW4oJywgJyl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuIl19